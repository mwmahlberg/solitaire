package solitaire_test

import (
	"errors"
	"fmt"

	"github.com/mwmahlberg/solitaire"
)

// This shows how to encrypt a plaintext using the solitaire
// package. The passphrase is used to key the deck, that is move the
// cards according to the solitaire algorithm.
// The encryption algorithm is as follows:
//  1. The plaintext is converted to uppercase, all non-letter characters
//     are removed and the remainder is padded to a multiple of 5 characters with X.
//     The result is the cleartext.
//  2. The ciphertext is generated by encrypting the cleartext with the
//     keystream.
//  4. When all plaintext characters are encrypted, the ciphertext is
//     returned as a byte slice.
//
// A cleartext character is encrypted into a cipertext character as follows:
//  1. The plaintext character is converted to a number: A=1, B=2, C=3, ..., Z=26.
//  2. A key is generated from the deck. The key is a card, which has a
//     value.
//  3. The value of the card added to the value of the plaintext character modulo 26 is
//     the value of the ciphertext character from the set of 1=A, 2=B, ..., 26=Z.
func Example_encrypt() {
	// Create a new solitaire instance with the passphrase "CRYPTONOMICON"
	s, err := solitaire.New(solitaire.WithPassphrase([]byte("CRYPTONOMICON")))
	switch err {
	case solitaire.ErrPassphraseIsNil:
		// Handle the case when the passphrase is nil. A passphrase should
		// never be nil, but may be empty, that is []byte("").
		//
		// If you want to use the default deck order, you can instead use the
		// solitaire.New() function without any options.

		fallthrough
	case solitaire.ErrInvalidPassphrase:
		// Handle the case when the passphrase contains a non-ASCII character.
		// The passphrase should be a valid ASCII string. The reason for this
		// is that the algorithm uses the ASCII values of the characters to
		// generate the deck order. If the passphrase contains non-ASCII
		// characters, the algorithm may now work as expected. The usage of
		// non-ASCII characters is not tested and hence not supported for now.

		panic(errors.Join(errors.New("cannot create solitaire instance"), err))
	}
	ciphertext, err := s.Encrypt([]byte("SOLITAIRE"))
	if err != nil {
		panic(errors.Join(errors.New("cannot encrypt"), err))
	}
	fmt.Printf("%s", ciphertext)
	// Output: KIRAK SFJAN
}
